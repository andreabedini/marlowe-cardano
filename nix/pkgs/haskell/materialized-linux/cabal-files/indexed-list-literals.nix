{ system
  , compiler
  , flags
  , pkgs
  , hsPkgs
  , pkgconfPkgs
  , errorHandler
  , config
  , ... }:
  ({
    flags = {};
    package = {
      specVersion = "1.10";
      identifier = { name = "indexed-list-literals"; version = "0.2.1.3"; };
      license = "BSD-3-Clause";
      copyright = "";
      maintainer = "dmillardurrant@gmail.com";
      author = "David Millar-Durrant";
      homepage = "https://github.com/davidm-d/indexed-list-literals";
      url = "";
      synopsis = "Type safe indexed list literals";
      description = "This is an incredibly simple library, which makes writing lists where the length is known at compile time a little bit nicer.\n\nIf you write a function with the signature\n\n> vector :: ILL input length output => input -> Vector length output\nthen\n\n> v :: Vector 3 Int\n> v = vector (1,2,3)\n>\n> x :: Vector 0 Double\n> x = vector $ ZeroTuple @Double\n>\n> y :: Vector 1 Double\n> y = vector (Only 1)\n>\n> z :: Vector 2 String\n> z = vector (\"Hello\", \"World\")\n\nIf want matrix literals you can write a function\n\n> matrix :: (ILL row width ty, ILL matrix height row) => matrix -> Matrix width height ty\nthen\n\n> a :: Matrix 0 0 Bool\n> a = matrix $ ZeroTuple @(ZeroTuple Bool)\n>\n> b :: Matrix 1 2 String\n> b = matrix $ Only (\"Hello\",\"World\")\n>\n> c :: Matrix 4 5 Double\n> c = matrix ((1,2,3,0,0)\n>            ,(4,5,6,0,0)\n>            ,(7,8,9,0,0)\n>            ,(0,0,0,0,0))\nThe full code is in test\\/Docs.hs\n\nThis only supports literals of length up to 20, though that can be easily extended using the code generator in src\\/Data\\/IndexedListLiterals.hs";
      buildType = "Simple";
      };
    components = {
      "library" = {
        depends = [
          (hsPkgs."base" or (errorHandler.buildDepError "base"))
          (hsPkgs."Only" or (errorHandler.buildDepError "Only"))
          ];
        buildable = true;
        };
      tests = {
        "IndexedListLiterals-test" = {
          depends = [
            (hsPkgs."base" or (errorHandler.buildDepError "base"))
            (hsPkgs."indexed-list-literals" or (errorHandler.buildDepError "indexed-list-literals"))
            (hsPkgs."hspec" or (errorHandler.buildDepError "hspec"))
            ];
          buildable = true;
          };
        };
      };
    } // {
    src = (pkgs.lib).mkDefault (pkgs.fetchurl {
      url = "http://hackage.haskell.org/package/indexed-list-literals-0.2.1.3.tar.gz";
      sha256 = "26e399e285ddf44822781559f7202ed821382457ed6c1c32bdaac7945c033f9d";
      });
    }) // {
    package-description-override = "-- Initial indexed-container-literals.cabal generated by cabal init.  For \n-- further documentation, see http://haskell.org/cabal/users-guide/\n\nname:                indexed-list-literals\nversion:             0.2.1.3\nsynopsis:            Type safe indexed list literals\nhomepage:            https://github.com/davidm-d/indexed-list-literals\nlicense:             BSD3\nlicense-file:        LICENSE\nauthor:              David Millar-Durrant\nmaintainer:          dmillardurrant@gmail.com\ndescription:\n  This is an incredibly simple library, which makes writing lists where the length is known at compile time a little bit nicer.\n  .\n  If you write a function with the signature\n  .\n  > vector :: ILL input length output => input -> Vector length output\n  then\n  .\n  > v :: Vector 3 Int\n  > v = vector (1,2,3)\n  >\n  > x :: Vector 0 Double\n  > x = vector $ ZeroTuple @Double\n  >\n  > y :: Vector 1 Double\n  > y = vector (Only 1)\n  >\n  > z :: Vector 2 String\n  > z = vector (\"Hello\", \"World\")\n  .\n  If want matrix literals you can write a function\n  .\n  > matrix :: (ILL row width ty, ILL matrix height row) => matrix -> Matrix width height ty\n  then\n  .\n  > a :: Matrix 0 0 Bool\n  > a = matrix $ ZeroTuple @(ZeroTuple Bool)\n  >\n  > b :: Matrix 1 2 String\n  > b = matrix $ Only (\"Hello\",\"World\")\n  >\n  > c :: Matrix 4 5 Double\n  > c = matrix ((1,2,3,0,0)\n  >            ,(4,5,6,0,0)\n  >            ,(7,8,9,0,0)\n  >            ,(0,0,0,0,0))\n  The full code is in test\\/Docs.hs\n  .\n  This only supports literals of length up to 20, though that can be easily extended using the code generator in src\\/Data\\/IndexedListLiterals.hs\n\n-- copyright:           \ncategory:            Data\nbuild-type:          Simple\nextra-source-files:  ChangeLog.md\ncabal-version:       >=1.10\n\nlibrary\n  exposed-modules:     Data.IndexedListLiterals\n  -- other-modules:       \n  -- other-extensions:    \n  build-depends:       base >= 4.9 && < 5\n                     , Only >= 0.1 && < 0.2\n  hs-source-dirs:      src\n  default-language:    Haskell2010\n\ntest-suite IndexedListLiterals-test\n            type: exitcode-stdio-1.0\n            main-is: Docs.hs\n            build-depends:       base, indexed-list-literals, hspec\n            hs-source-dirs:      test\n            default-language:    Haskell2010\n\nsource-repository head\n  type: git\n  location: https://github.com/davidm-d/indexed-list-literals\n";
    }